# Reproducibility
This library uses the Python standard library's [random](https://docs.python.org/3/library/random.html) module to generate pseudorandom numbers. If you want to limit nondeterministic results, consider setting the [random seed](https://docs.python.org/3/library/random.html#random.seed) in programs that use the Augraphy library, by including `random.seed(42)` in your scripts. (The number 42 is not required; feel free to choose your own memorable seed when requiring deterministic RNG).

Depending on your application, you may also need to set the [numpy random seed](https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.random.seed.html) or the seeds for other sources of randomness (for a brief overview, see [here](https://pytorch.org/docs/stable/notes/randomness.html)), but Augraphy does not depend on these for random number generation.

---

# Per-process Randomness vs. In-process Randomness
One common misconception about setting the random seed is that this will guarantee identical pipeline runs within the same Python process. On the contrary, setting the seed will guarantee identical pipeline runs between multiple invocations of the same Python script.

For example, consider the following code:

``` python
from augraphy import *
import random
import cv2

random.seed(0)

img = cv2.imread("image.png")

augmented1 = default_augraphy_pipeline().augment(img)["output"]
augmented2 = default_augraphy_pipeline().augment(img)["output"]

cv2.imwrite("augmented1.png", augmented1)
cv2.imwrite("augmented2.png", augmented2)

print(augmented1.shape == augmented2.shape and not np.bitwise_xor(augmented1,augmented2).any())
```

Running this script once will produce the two images `augmented1.png` and `augmented2.png` in the local directory, and print `False` because two successive pipeline executions within the same Python process are not equivalent.

We can modify the script slightly to save the augmented images under different names:

``` python
...
cv2.imwrite("augmented1_new.png", augmented1)
cv2.imwrite("augmented2_new.png", augmented2)
```

Run the new script to generate `augmented1_new.png` and `augmented2_new.png`.

We can now run the following script to check whether `augmented1.png` and `augmented1_new.png`, and `augmented2.png` and `augmented2_new.png` are identical:

``` python
import cv2
import numpy as np

c1 = cv2.imread("augmented1.png")
c1_new = cv2.imread("augmented1_new.png")

c2 = cv2.imread("augmented2.png")
c2_new = cv2.imread("augmented2_new.png")

print(c1.shape == c1_new.shape and not np.bitwise_xor(c1,c1_new).any())
print(c2.shape == c2_new.shape and not np.bitwise_xor(c2,c2_new).any())
```

The print statements will report whether the shape of the images is the same, and whether there are any non-equal pixels between the two images.

``` bash
$ python3 testaugmenteds.py
True
True
```

Indeed, the images generated by pipeline executions in successive Python processes are identical, and fixing the random seed made this possible.
